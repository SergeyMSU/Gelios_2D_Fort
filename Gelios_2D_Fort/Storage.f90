
module STORAGE
    implicit none 

    !! Набор общепринятых констант (которые никогда не поменяются)
    real(8), parameter :: par_pi = acos(-1.0_8) 
    real(8), parameter :: par_sqrtpi = sqrt(par_pi)

    integer(4), parameter :: par_n_zone = 6! 7  !  Количество радиусов (но есть ещё внешняя зона)
	integer(4), parameter :: par_m_zone = 7! 6  !  Количество лучей по углу (от 0 до 180)
    integer(4), parameter :: par_n_potok = 32! 32  ! Число потоков (у каждого потока свой стек)
    integer(4), parameter :: par_n_parallel = 20  ! Для распараллеливания цикла (т.е. каждый поток будет в среднем обрабатывать

    real(8), parameter :: par_Rmax = 220.0  !  Радиус сферы, с которой запускаем частицы

    real(8), parameter :: par_a_2 = 0.130738_8        !! Параметр в сечении перезарядки

    ! Число частиц у каждого потока!
	! Число должно быть кратно par_n_parallel
	integer(4), parameter :: MK_k_multiply = 3 * 18!6 * 11! 17   ! 1 = 10 минут счёта (с пикапами 18 минут)
	integer(4), parameter :: MK_k_mul1 = 6 * MK_k_multiply! 6
	integer(4), parameter :: MK_k_mul2 = 1 * MK_k_multiply! 
	integer(4), parameter :: MK_N1 = MK_k_mul1 * 60/par_n_parallel   ! 600 Число исходных частиц первого типа (с полусферы)
	integer(4), parameter :: MK_N2 = MK_k_mul1 * 20/par_n_parallel  ! 200
	integer(4), parameter :: MK_N3 = MK_k_mul2 * 20/par_n_parallel     ! (вылет сзади)
	integer(4), parameter :: MK_N4 = MK_k_mul1 * 20/par_n_parallel   ! (вылет спереди с цилиндра)

    !! Модуль хранит всю сетку со всеми параметрами
    TYPE Setka 

        character(len=5) :: name = "00000"
        logical :: init_geo = .False.   ! Инициализирована ли данная сетка (выделена ли память под массивы геометрии)


        ! Набор переменных, определяющих структуру сетки
        integer(4) :: par_m_A = 20! 30      ! Количество лучей A в плоскости
        integer(4) :: par_m_BC = 10! 18      ! Количество лучей B/C в плоскости
        integer(4) :: par_m_O = 10! 17      ! Количество лучей O в плоскости
        integer(4) :: par_m_K = 8! 7      ! Количество лучей K в плоскости
        real(8) :: par_triple_point = 13.0 * par_pi/40.0     ! До какого угла начиная от pi/2 (с положительного x) тройная точка
        real(8) :: par_triple_point_2 = 7.0 * par_pi/40.0     ! Под каким углом выходит луч после тройной точки начиная от pi/2 (с положительного x) 
        
        ! Количество точек по лучам A
        integer(4) :: par_n_TS =  33! 26                    ! Количество точек до TS (TS включается)
        integer(4) :: par_n_HP =  63! 40                 ! Количество точек до HP (HP включается)  всё от 0 считается
        integer(4) :: par_n_BS =  89! 60! 5                 ! Количество точек BS (BS включается)
        integer(4) :: par_n_END = 98! 72! 6                ! Количество точек до конца сетки (конец включается)
        integer(4) :: par_n_IA =  20! 12                   ! Количество точек, которые входят во внутреннюю область
        integer(4) :: par_n_IB =  22! 14                   ! Количество точек, которые входят во внутреннюю область (с зазором)

        ! Набор параметров, задающих размеры сетки
        real(8) :: par_R_character = 35.0         ! Характерный размер в задаче (расстояние до TS на начальном этапе построения сетки)
        real(8) :: par_R0 = 0.197035         ! Характерный размер 1 а.е. (внутренней сферы) Там находится вторая точка на лучах от цетра (первая находится в нуле)
        real(8) :: par_R_END = 300.0         !  
        real(8) :: par_R_LEFT = -240.0 ! -390.0         !  Левая граница
        real(8) :: par_R_inner = 9.0! 5.0_8     ! До какого расстояния внутренняя сфера

        !! Физические параметры ---------------------------------------
        real(8) :: par_a_2 = 0.130738_8        ! Параметр в сечении перезарядки
        real(8) :: par_ggg = 5.0/3.0                 ! До какого расстояния внутренняя сфера
        real(8) :: par_Velosity_inf = -2.54279_8
        real(8) :: par_n_H_LISM = 3.5_8
        real(8) :: par_Kn = 49.9018   !0.4326569808         ! в перезарядке
        !! -------------------------------------------------------------

        !! Набор параметров сгущения
        real(8) :: par_kk1 = 2.0_8     ! Степень сгущения сетки к нулю в области до TS: 1 - линейное, 2 - квадратичное и т.д.
        real(8) :: par_kk2 = 1.7_8     ! Степень сгущения в головной области на бесконечности
        real(8) :: par_kk3 = 1.8_8     ! Степень сгущения в хвосте
        real(8) :: par_kk31 = 1.0_8     ! Степень сгущения в хвосте для точек на контакте (первая точка в О - луче)
        real(8) :: par_kk13 = 1.8_8     ! Степень сгущения точек в головной области во внешнем ударном слое  от 0 до 1
        real(8) :: par_kk131 = 0.1_8
        real(8) :: par_kk132 = 1.5_8
        real(8) :: par_kk14 = 1.0_8     ! Степень сгущения точек в головной области во внутреннем ударном слое  от 0 до 1
        ! (сгущение сразу к TS и HP)  
        real(8) :: par_kk12 = 1.0_8     ! Степень сгущения точек до TS к ударной волне  >= 1
        ! Должно делиться на 4 для удобного вывода результатов в плоскостях

        !! Поверхностное натяжение
        real(8) :: par_nat_TS = 0.003_8 ! 0.003_8   ! Поверхностное натяжение
        real(8) :: par_nat_HP = 0.005_8   ! Поверхностное натяжение
        real(8) :: par_nat_BS = 0.002_8   ! Поверхностное натяжение

        !! Параметры для Монте-Карло ----------------------------------------------------------

        integer(4), allocatable :: sensor(:, :, :)  !(3, 2, : par_n_potok - число потоков)  ! датчики случайных чисел 
	    ! Каждому потоку по два датчика

        integer(4), allocatable :: stek(:)   ! (: число потоков) Переменная чтения и записи в стек
	    ! Где стоит переменная, там что-то лежит, чтобы записать, нужно увеличить значение на 1

        real(8), allocatable :: M_K_particle(:, :, :)   ! Частицы (8, par_stek, число потоков)
        ! (три координаты, три скорости, вес, радиус перегелия)
        integer(4), allocatable :: M_K_particle_2(:, :, :)  ! Частицы (4, par_stek, число потоков)
        ! (в какой ячейке частица, сорт, зона назначения по r, зона назначения по углу)
        logical(4), allocatable :: M_K_particle_3(:, :, :, :)  ! Частицы (par_n_zone + 1, par_m_zone + 1, par_stek, число потоков)
        ! (в какой ячейке частица, сорт, зона назначения по r, зона назначения по углу)

        real(8) :: MK_R_zone(par_n_zone)   ! Радиусы зон
        real(8) :: MK_al_zone(par_m_zone)   ! Лучи зон
        real(8) :: MK_SINKR(par_m_zone + 1)   ! Критические синусы для каждой зоны по углу
        real(8), allocatable :: MK_Mu(:, :, :)   ! Веса зон (par_n_zone + 1, par_m_zone + 1, сортов)
        real(8), allocatable :: MK_Mu_statistic(:, :, :)   ! Веса зон (par_n_zone + 1, par_m_zone + 1, сортов)
        ! Для накапливания весов зон

        real(8) :: MK_gam_zone(par_n_zone)   ! Параметр гамма для зон
        real(8) :: MK_A0_, MK_A1_   ! Параметры для начального запуска

        real(8) :: sqv_1, sqv_2, sqv_3, sqv_4, sqv   ! Потоки частиц через 
        real(8) :: MK_mu1, MK_mu2, MK_mu3, MK_mu4
        integer(4) :: MK_N                  ! Сколько всего частиц запущено (сумма по всем потокам)

        real(8) :: MK_Mu_mult = 100.0_8  ! На что домножаем веса для избежания потери точности

        !! -------------------------------------------------------------------------------------
        

        integer(4) :: par_n_points                         ! Всего точек в сетке (считается при инициализации сетки)

        real(8), allocatable :: gl_yzel(:, :, :)   ! (2, :, 2) набор координат узлов сетки
        real(8), allocatable :: gl_yzel_Vel(:, :)   ! (2, :) Скорость движения узлов сетки  !TODO NO-SAVE
        ! Этот массив не надо сохранять при сохранении сетки в файл - это промежуточный рабочий массив
        integer(4), allocatable :: gl_Point_num(:)   ! Сколько раз скорость записана в узел  !TODO NO-SAVE

        ! Лучи, на которых распологаются точки сетки
        integer(4), allocatable :: gl_RAY_A(:,:)   ! Набор А-лучей размерности 3 (на этом луче, в этой плоскости)
        integer(4), allocatable :: gl_RAY_B(:,:)   ! Набор B-лучей размерности 3 (на этом луче, в этой плоскости)
        integer(4), allocatable :: gl_RAY_C(:,:)   ! Набор C-лучей размерности 3 (на этом луче, в этой плоскости)
        integer(4), allocatable :: gl_RAY_O(:,:)   ! Набор O-лучей размерности 3 (на этом луче, в этой плоскости)
        integer(4), allocatable :: gl_RAY_K(:,:)   ! Набор K-лучей размерности 3 (на этом луче, в этой плоскости)
        integer(4), allocatable :: gl_RAY_D(:,:)   ! Набор D-лучей размерности 3 (на этом луче, в этой плоскости)
        integer(4), allocatable :: gl_RAY_E(:,:)   ! Набор E-лучей размерности 3 (на этом луче, в этой плоскости)

        ! Ячейки
        integer(4), allocatable :: gl_Cell_A(:,:)   ! Набор A-ечеек размерности 3 (на этом луче, в этой плоскости)
        integer(4), allocatable :: gl_Cell_B(:,:)   ! Набор B-ечеек размерности 3 (на этом луче, в этой плоскости)
        integer(4), allocatable :: gl_Cell_C(:,:)   ! Набор C-ечеек размерности 3 (на этом луче, в этой плоскости)

        integer(4), allocatable :: gl_all_Cell(:,:)   ! Весь набор ячеек (4, :) - первая координата массива - это набор узлов ячейки

        integer(4), allocatable :: gl_Cell_neighbour(:,:)   ! (4, :) Набор из 4 соседей для каждой ячейки  !! соседи согласованы с соседями для граней!
        ! -1   ! Граница (набегающий поток)
        ! -2   ! Выходная граница
        ! -3   ! Граница верхний цилиндр
        ! -4   ! Ось симметрии

        integer(4), allocatable :: gl_all_Cell_zone(:)   ! зона ячейки
        ! 1, 2, 3, 4

        integer(4), allocatable :: gl_Cell_gran(:,:)        ! (4, :) Набор из 4 граней для каждой ячейки (если номер = 0, то грани нет в этом направлении)
        ! 0 - нет грани (такие ячейки есть, например возде нуля)
        !! Отрицательных номеров у грани нет!
        real(8), allocatable :: gl_Cell_gran_dist(:, :, :)      ! (4, :, 2) Расстояния от ценра ячеек до центров граней

        real(8), allocatable :: gl_Cell_Centr(:, :, :)   ! (2, : число ячеек, 2) набор координат центров ячеек
        

        integer(4), allocatable :: gl_all_Gran(:,:)       ! Все грани (2,:) имеют по 2 узла
        integer(4), allocatable :: gl_Gran_neighbour(:,:) ! Соседи каждой грани (2,:) имеют по 2 соседа, нормаль ведёт от первого ко второму
        real(8), allocatable :: gl_Gran_normal(:, :, :)       ! (2, :, 2) Нормаль грани     !! Нормаль идёт от первой ячейки ко второй обязательно!                   
        real(8), allocatable :: gl_Gran_length(:, :)       ! (:, 2) Длина грани                       
        real(8), allocatable :: gl_Gran_Center(:, :, :)       ! (2, :, 2) Центр грани                       
        
        integer(4), allocatable :: gl_Gran_neighbour_TVD(:,:) ! TVD-Соседи каждой грани (2,:) имеют по 2 соседа
        ! 0 - значит соседа нет
        ! При этом первый TVD-сосед - это сосед первого обычного соседа. Т.е. нормаль грани тоже ведёт от первого ко второму TVD-соседу

        
        real(8), allocatable :: gl_Cell_belong(:,:,:)      ! (3, 4, :)  ! Определяются для координат на первом слое по времени
        ! для каждой грани коэффициенты A, B, C   Ax + By + C = 0  (если больше 0, то точка вне ячейки! Т.е. нормаль внешняя)
        real(8), allocatable :: gl_Cell_square(:,:)      ! (:, 2)

        character, allocatable :: gl_Cell_type(:)           ! Тип каждой ячейки А, Б, С
        integer(4), allocatable :: gl_Cell_number(:, :)     ! (2, :) номер каждой ячейки внутри своего типа

        ! Поверхности выделения
        integer(4), allocatable :: gl_HP(:)            ! Контакт - номеры граней, которые образуют контактную поверхность
        ! Контакт состоит из номеров граней
        integer(4), allocatable :: gl_TS(:)
        integer(4), allocatable :: gl_BS(:)
        !? ПРОВЕРЕНО, чтобы нормали у граней-поверхностей были ориентированы "наружу"
        !? ПРОВЕРЕНО, что у граней первый и второй узел правильно расположены (с права на лево)

        integer(4), allocatable :: gl_Gran_type(:)      ! Показывает тип грани 
        ! (0 - обычная, 1 - TS, 2 - HP, 3 - BS)     

        integer(4), allocatable :: gl_Gran_shem(:)      ! Показывает схему для грани
        ! 0 - Lax
        ! 1 - HLL
        ! 2 - HLLC
        ! 3 - Godunov

        !! ФИЗИКА
        integer(4) :: n_Hidrogen = 4  ! Число сортов атомов водорода
        integer(4) :: n_par = 5  !! Число физических параметров в задаче
        ! 5 газодинамических
        ! 4 * n_Hidrogen - Водород

        real(8), allocatable :: gd(:, :, :)  ! (n_par, :, 2 временной слой)
        ! (rho p u v Q)
        real(8), allocatable :: hydrogen(:, :, :, :)  ! (5, n_Hidrogen, :, 2 временной слой)
        ! rho p u v T

    END TYPE Setka

    TYPE Inter_Setka  ! Сетка для интерполяции

        logical :: init = .False.   ! Инициализирована ли данная сетка (выделена ли память под массивы геометрии)
        real(8), allocatable :: gl_yzel(:, :)   ! (2, :) набор координат узлов сетки

        !? Наблюдательный факт
        ! Почти все ячейки состояит из 4 граней, но есть несколько треугольников
        ! В этом случае четвёрный узел равен первому (для всех кроме одного)
        ! В единсвенном варианте четвёртый равен третьему

        ! Ячейки
        !! Здесь А и B ячейки пересекаются (как раз на стыке A и B)
        integer(4), allocatable :: gl_Cell_A(:,:)   ! Набор A-ечеек размерности 3 (на этом луче, в этой плоскости)
        integer(4), allocatable :: gl_Cell_B(:,:)   ! Набор B-ечеек размерности 3 (на этом луче, в этой плоскости)
        integer(4), allocatable :: gl_Cell_C(:,:)   ! Набор C-ечеек размерности 3 (на этом луче, в этой плоскости)

        integer(4), allocatable :: gl_all_Cell(:,:)   ! Весь набор ячеек (4, :) - первая координата массива - это набор узлов ячейки
        real(8), allocatable :: gl_Cell_center(:,:)   ! Весь набор ячеек (2, :) - первая координата массива - это набор узлов ячейки

        logical, allocatable :: gl_all_triangle(:)
        ! .True. - если ячейка является треугольником и .False. в противном случае

        integer(4), allocatable :: gl_Cell_neighbour(:,:)   ! (4, :) Набор из 4 соседей для каждой ячейки 
        real(8), allocatable :: gl_Cell_Belong(:, :, :)       ! Все грани (3, 4, :) имеют по A B C, 4 грани в ячейке, 
        ! Ax + By + C = 0  (если > 0 то за пределами ячейки)

        real(4), allocatable :: gl_Cell_interpol_matrix(:, :, :)   ! (4, 4, :) Набор из 4 соседей для каждой ячейки
        ! Ax + By + Cxy + D
        ! Ax + By + C
        ! 
        ! интерполяционная матрица для каждой ячейки

        !! ФИЗИКА
        integer(4) :: n_Hidrogen = 4  ! Число сортов атомов водорода
        integer(4) :: n_par = 5  !! Число физических параметров в задаче
        ! 5 газодинамических
        ! 4 * n_Hidrogen - Водород

        real(8), allocatable :: gd(:, :)  ! (n_par, :)
        ! (rho p u v Q)
        real(8), allocatable :: hydrogen(:, :, :)  ! (5, n_Hidrogen, :)
        ! rho p u v T

    END TYPE Inter_Setka


    TYPE Surfaces
        ! Модуль хранения поверхностей для движения сетки к этим поверхностям
        ! Такое приём нужен, например, для перестройки текущей сетки (так как добавлять ячейки нельзя, но можно построить другую сетку)
        ! и подвинуть её поверхности
        logical :: init = .False.

        real(8), allocatable :: TS(:, :)  ! (2, :) угол, радиус
        real(8), allocatable :: HP(:, :)  ! (4, :) угол, радиус, x, y
        real(8), allocatable :: BS(:, :)  ! (4, :) угол, радиус, x, y

    END TYPE Surfaces
	
	!! Набор глобальных переменных 
    TYPE (Setka):: gl_S1
    TYPE (Setka):: gl_S3

    TYPE (Inter_Setka):: gl_S2

    TYPE (Surfaces):: gl_surf1


    contains 


end module STORAGE



! N2 = size(SS%gl_Cell_A(1, :))
! N1 = size(SS%gl_Cell_A(:, 1))

! 2.0 * N1 * N2 - N1

! N2 = size(SS%gl_Cell_B(1, :))
! N1 = size(SS%gl_Cell_B(:, 1))

! 2.0 * N1 * N2

! N2 = size(SS%gl_Cell_C(1, :))
! N1 = size(SS%gl_Cell_C(:, 1))

! 2.0 * N1 * N2 + N1